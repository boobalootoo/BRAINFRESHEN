<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tree Leaf Cutout</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      position: absolute;
      cursor: grab;
    }
  </style>
</head>
<body>
<script>
const trees = [
  { name: 'alder', tree: 'alder.png', leaf: 'alderleaf.png' },
  { name: 'ash', tree: 'ash.png', leaf: 'ashleaf.png' },
  { name: 'birch', tree: 'birch.png', leaf: 'birchleaf.png' },
  { name: 'chestnut', tree: 'chestnut.png', leaf: 'chestnutleaf.png' },
  { name: 'oak', tree: 'oak.png', leaf: 'oakleaf.png' },
  { name: 'pine', tree: 'pine.png', leaf: 'pineleaf.png' },
  { name: 'willow', tree: 'willow.png', leaf: 'willowleaf.png' }
];

function loadImage(src) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = e => reject(e);
    img.src = src;
  });
}

async function createMaskedTree(tree) {
  const [treeImg, leafImg] = await Promise.all([
    loadImage(tree.tree),
    loadImage(tree.leaf)
  ]);

  // Scale tree image if too large for screen
  const maxWidth = window.innerWidth / 4;
  const maxHeight = window.innerHeight / 3;
  let treeWidth = treeImg.width;
  let treeHeight = treeImg.height;

  const treeRatio = treeWidth / treeHeight;
  if (treeWidth > maxWidth) {
    treeWidth = maxWidth;
    treeHeight = treeWidth / treeRatio;
  }
  if (treeHeight > maxHeight) {
    treeHeight = maxHeight;
    treeWidth = treeHeight * treeRatio;
  }

  const canvas = document.createElement('canvas');
  canvas.width = treeWidth;
  canvas.height = treeHeight;
  const ctx = canvas.getContext('2d');

  // Draw tree
  ctx.drawImage(treeImg, 0, 0, treeWidth, treeHeight);

  // Resize leaf
  const maxLeafWidth = treeWidth / 2;
  const maxLeafHeight = treeHeight / 2;
  const leafRatio = leafImg.width / leafImg.height;

  let leafW = maxLeafWidth;
  let leafH = leafW / leafRatio;

  if (leafH > maxLeafHeight) {
    leafH = maxLeafHeight;
    leafW = leafH * leafRatio;
  }

  const cutX = (treeWidth - leafW) / 2;
  const cutY = (treeHeight - leafH) / 2;

  // Apply cutout
  ctx.globalCompositeOperation = 'destination-out';
  ctx.drawImage(leafImg, cutX, cutY, leafW, leafH);
  ctx.globalCompositeOperation = 'source-over';

  // Position randomly but fully on screen
  const maxLeft = window.innerWidth - treeWidth;
  const maxTop = window.innerHeight - treeHeight;
  canvas.style.left = `${Math.random() * maxLeft}px`;
  canvas.style.top = `${Math.random() * maxTop}px`;

  // Speak name on click
  canvas.addEventListener('click', () => {
    const utterance = new SpeechSynthesisUtterance(tree.name);
    window.speechSynthesis.speak(utterance);
  });

  enableDrag(canvas);
  document.body.appendChild(canvas);
}

function enableDrag(el) {
  let isDragging = false;
  let offsetX = 0, offsetY = 0;

  el.addEventListener('mousedown', e => {
    isDragging = true;
    offsetX = e.offsetX;
    offsetY = e.offsetY;
    el.style.cursor = 'grabbing';
  });

  window.addEventListener('mousemove', e => {
    if (isDragging) {
      el.style.left = `${e.clientX - offsetX}px`;
      el.style.top = `${e.clientY - offsetY}px`;
    }
  });

  window.addEventListener('mouseup', () => {
    isDragging = false;
    el.style.cursor = 'grab';
  });
}

// Load and create all trees
(async () => {
  for (const tree of trees) {
    try {
      await createMaskedTree(tree);
    } catch (e) {
      console.error('Error loading tree:', tree.name, e);
    }
  }
})();
</script>
</body>
</html>
