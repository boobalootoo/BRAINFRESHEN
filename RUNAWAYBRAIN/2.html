<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Train Timer Visualizer</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom CSS variables for train positioning */
        :root {
            --train-translate-x: 0px; /* Changed to px for pixel-accurate movement */
        }

        /* Define the position of the train using a CSS variable for smooth transitions */
        #train-container {
            position: absolute;
            top: -1.7rem; /* Adjusted lift to center over the rails */
            /* Start the train container at the visual edge of the track (0%) */
            left: 0%; 
            
            /* Apply the transformation with a smooth transition */
            transform: translateX(var(--train-translate-x));
            transition: transform 1s linear; 
            will-change: transform;
            z-index: 10;
        }

        /* Adjust the size of the track container */
        #track-container {
            position: relative;
            height: 4rem;
            width: 90%; 
            max-width: 1200px;
        }

        /* Styling for the minute segments (sleepers) */
        .track-segment {
            width: 1px; 
            height: 1.5rem;
            transition: all 0.5s ease;
        }

        /* Styling for the rail lines */
        .rail {
            position: absolute;
            height: 0.5rem;
            width: 100%;
            background-color: #3f3f46; 
            border-radius: 9999px; 
        }

        /* Custom button styling */
        .control-button {
            @apply px-6 py-3 rounded-full font-bold transition-all duration-200 shadow-lg;
            @apply focus:outline-none focus:ring-4 focus:ring-offset-2;
        }

        .start-button {
            @apply bg-green-500 hover:bg-green-600 text-white focus:ring-green-300;
        }

        .mute-button {
            @apply bg-gray-500 hover:bg-gray-600 text-white focus:ring-gray-300;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4 font-sans">

    <div class="w-full max-w-4xl bg-white p-8 rounded-xl shadow-2xl border-b-8 border-gray-900 flex flex-col items-center">
        
        <!-- Duration Slider -->
        <div class="w-full max-w-sm mb-8">
            <label for="duration-slider" id="duration-label" class="block text-center text-xl font-bold text-gray-800 mb-4">
                Duration: 1 Minute
            </label>
            <input type="range" id="duration-slider" min="1" max="60" value="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer focus:outline-none focus:ring-2 focus:ring-indigo-500 transition-shadow duration-150" step="1">
            <div class="flex justify-between text-sm text-gray-500 mt-1 px-1">
                <span>1 min</span>
                <span>60 min</span>
            </div>
        </div>

        <!-- Status Display -->
        <div id="status-display" class="text-3xl font-mono font-extrabold text-gray-700 mb-12 h-10 text-center">
            Ready (00:00)
        </div>

        <!-- Track & Train Area -->
        <div class="flex justify-center w-full mb-12">
            <div id="track-container" class="mx-auto">

                <!-- The Train Engine -->
                <div id="train-container" class="cursor-pointer" title="I am the Minute Express!">
                    <!-- Flipped train emoji -->
                    <span id="train-emoji" class="text-5xl scale-x-[-1] inline-block" role="img" aria-label="Train Emoji">ðŸš‚</span>
                </div>

                <!-- Top Rail -->
                <div class="rail top-0 mt-2"></div>
                <!-- Bottom Rail -->
                <div class="rail bottom-0 mb-2"></div>

                <!-- Track Sleepers (60 segments for visualization) -->
                <div id="track-segments" class="absolute inset-0 flex justify-between items-center px-2">
                    <!-- Segments generated by JavaScript -->
                </div>
            </div>
        </div>
        <!-- End Track & Train Area -->

        <!-- Controls -->
        <div class="flex space-x-4">
            <button id="start-reset-button" class="control-button start-button">
                Start Timer
            </button>
            <button id="mute-button" class="control-button mute-button">
                <span id="mute-icon">ðŸ”ˆ</span> Mute
            </button>
        </div>
    </div>

    <script type="module">
        // --- Configuration & State ---
        let isAudioInitialized = false;
        let isMuted = false;
        
        let durationMinutes = 1;
        let totalDurationSeconds = 60;
        let startTime = 0;
        let elapsedTimeOnPause = 0; // Tracks total elapsed time, used for resume/reset
        let animationFrameId = null;
        let isRunning = false;
        
        // --- DOM Elements ---
        const trackSegmentsDiv = document.getElementById('track-segments');
        const trackContainer = document.getElementById('track-container');
        const trainContainer = document.getElementById('train-container');
        const startResetButton = document.getElementById('start-reset-button');
        const muteButton = document.getElementById('mute-button');
        const statusDisplay = document.getElementById('status-display');
        const muteIcon = document.getElementById('mute-icon');
        const durationSlider = document.getElementById('duration-slider');
        const durationLabel = document.getElementById('duration-label');
        
        // --- Core Movement Variables ---
        let maxTravelDistancePx = 0; // The total distance the train can translate in pixels
        let trainWidthPx = 0; // The pixel width of the train emoji

        // --- Native Audio Setup ---
        let chugAudio = null;
        let chooAudio = null;
        
        // Raw GitHub URLs for audio files
        const CHUG_URL = 'https://raw.githubusercontent.com/boobalootoo/BRAINFRESHEN/main/RUNAWAYBRAIN/chug.wav';
        const CHOO_URL = 'https://raw.githubusercontent.com/boobalootoo/BRAINFRESHEN/main/RUNAWAYBRAIN/choo.mp3';

        function initializeAudio() {
            if (isAudioInitialized) return;
            
            // 1. Chug Sound (Looping while moving)
            chugAudio = new Audio(CHUG_URL);
            chugAudio.loop = true;
            chugAudio.volume = 0.5; // Default volume
            
            // 2. Choo Sound (Plays once at the end)
            chooAudio = new Audio(CHOO_URL);
            chooAudio.volume = 1.0; // Default volume
            
            // Pre-load audio elements
            chugAudio.load();
            chooAudio.load();

            isAudioInitialized = true;
        }

        function setMute(muteState) {
            isMuted = muteState;
            muteIcon.textContent = isMuted ? 'ðŸ”‡' : 'ðŸ”ˆ';
            muteButton.classList.toggle('bg-red-500', isMuted);
            muteButton.classList.toggle('bg-gray-500', !isMuted);

            if (chugAudio) chugAudio.volume = isMuted ? 0 : 0.5;
            if (chooAudio) chooAudio.volume = isMuted ? 0 : 1.0;
        }
        
        // --- Duration and Status Logic ---

        function updateDuration(newDuration) {
            durationMinutes = parseInt(newDuration, 10);
            totalDurationSeconds = durationMinutes * 60;
            durationLabel.textContent = `Duration: ${durationMinutes} Minute${durationMinutes > 1 ? 's' : ''}`;
            
            // Update status display to reflect the new total duration when not running
            if (!isRunning) {
                updateStatusDisplay(0); 
            }
        }

        function updateStatusDisplay(elapsedSeconds) {
            const remainingSeconds = Math.max(0, totalDurationSeconds - elapsedSeconds);
            const minutes = Math.floor(remainingSeconds / 60).toString().padStart(2, '0');
            const seconds = Math.floor(remainingSeconds % 60).toString().padStart(2, '0');
            
            statusDisplay.textContent = isRunning 
                ? `Remaining: ${minutes}:${seconds}`
                : `Ready (${minutes}:${seconds})`;

            const isFinished = elapsedSeconds >= totalDurationSeconds;
            startResetButton.textContent = isRunning ? 'Stop/Pause' : (isFinished ? 'Reset' : 'Start Timer');
            
            // Visual feedback for running/paused state
            startResetButton.classList.toggle('start-button', !isRunning && !isFinished);
            startResetButton.classList.toggle('bg-red-500', isRunning);
            startResetButton.classList.toggle('bg-blue-500', !isRunning && isFinished);
        }

        // --- Core Timer Logic and Movement ---

        function calculateMovementDimensions() {
            // Recalculate track and train size on start/resize
            const trackWidth = trackContainer.getBoundingClientRect().width;
            const trainRect = trainContainer.getBoundingClientRect();
            
            // Since the train is flipped and moves left-to-right, its front is the right edge of its container.
            // We need to measure the actual visual width of the emoji to correct the travel distance.
            // A precise way is hard, so we use a safe constant value for the 5xl emoji size.
            // The emoji itself is smaller than its bounding box. 
            // We'll use the bounding box width and subtract a small buffer.
            trainWidthPx = trainRect.width; 
            
            // Max travel distance is the full track width minus the train's width.
            // This ensures the train is fully visible at 0px and its front reaches the end at maxTravelDistancePx.
            maxTravelDistancePx = trackWidth - trainWidthPx; 
        }


        function updateTrainPosition(timestamp) {
            if (!isRunning) return;

            // Calculate total elapsed time: time since startTimer was called + time elapsed before pause
            const timeElapsedSinceStart = (Date.now() - startTime) / 1000;
            const elapsedSeconds = timeElapsedSinceStart + elapsedTimeOnPause; 
            
            let percentage = (elapsedSeconds / totalDurationSeconds) * 100;
            
            // Cap at 100%
            if (percentage >= 100) {
                percentage = 100;
                stopTimer(true); // Signal completion
            }
            
            // Calculate pixel position based on the percentage of travel distance
            const currentTravelPx = (percentage / 100) * maxTravelDistancePx;
            
            // Set the CSS variable using pixels
            trainContainer.style.setProperty('--train-translate-x', `${Math.min(currentTravelPx, maxTravelDistancePx)}px`);

            // Update status display
            updateStatusDisplay(elapsedSeconds);

            // Continue animation loop
            if (isRunning) {
                animationFrameId = requestAnimationFrame(updateTrainPosition);
            }
        }

        function startTimer() {
            if (isRunning) return;
            
            initializeAudio(); 
            calculateMovementDimensions(); // Calculate dimensions on start

            // Record the current time. The total elapsed time will be (Date.now() - startTime) + elapsedTimeOnPause
            startTime = Date.now();

            isRunning = true;
            
            // Ensure train is correctly positioned at the start of the current elapsed time when resuming
            const startPercentage = (elapsedTimeOnPause / totalDurationSeconds) * 100;
            const startTranslationPx = (startPercentage / 100) * maxTravelDistancePx;
            trainContainer.style.setProperty('--train-translate-x', `${Math.min(startTranslationPx, maxTravelDistancePx)}px`);
            
            if (chugAudio && !isMuted) {
                chugAudio.play().catch(e => console.error("Chugging sound playback failed:", e));
            }
            
            animationFrameId = requestAnimationFrame(updateTrainPosition);
        }

        function stopTimer(completed = false) {
            if (!isRunning && !completed) return; 
            
            isRunning = false;
            cancelAnimationFrame(animationFrameId);
            
            if (chugAudio) chugAudio.pause();

            // Calculate the time elapsed *during* the last run segment
            const timeElapsedSinceStart = (Date.now() - startTime) / 1000;
            
            if (completed) {
                elapsedTimeOnPause = totalDurationSeconds; // Timer reached end
                
                // --- FIX: Explicitly snap the train to the pixel-corrected end of the track ---
                trainContainer.style.setProperty('--train-translate-x', `${maxTravelDistancePx}px`); 
                // -----------------------------------------------------------------

                if (chooAudio && !isMuted) {
                    chooAudio.currentTime = 0; // Rewind to start
                    chooAudio.play().catch(e => console.error("Choo sound playback failed:", e));
                }
            } else {
                // Paused: Add the time elapsed in the last run segment to the total paused time
                elapsedTimeOnPause += timeElapsedSinceStart;
            }
            
            updateStatusDisplay(elapsedTimeOnPause);
        }

        function resetTimer() {
            isRunning = false;
            cancelAnimationFrame(animationFrameId);
            if (chugAudio) {
                chugAudio.pause();
                chugAudio.currentTime = 0; // Also rewind chug sound
            }
            
            startTime = 0;
            elapsedTimeOnPause = 0; // Crucial: Reset paused time
            trainContainer.style.setProperty('--train-translate-x', `0px`);
            updateStatusDisplay(0);
            durationSlider.disabled = false; // Re-enable slider after reset
        }
        
        // --- Event Handlers ---
        startResetButton.addEventListener('click', () => {
            initializeAudio(); 
            
            // Check if timer is completed using the accumulated time
            const isFinished = elapsedTimeOnPause >= totalDurationSeconds && totalDurationSeconds > 0;
            
            if (isRunning) {
                stopTimer(false); // Pause
                durationSlider.disabled = false; // Re-enable slider on pause
            } else if (isFinished) {
                resetTimer(); // Reset
                durationSlider.disabled = false;
            } else {
                startTimer(); // First start or resume
                durationSlider.disabled = true; // Disable slider while running
            }
        });

        muteButton.addEventListener('click', () => {
            initializeAudio(); 
            setMute(!isMuted);
        });

        durationSlider.addEventListener('input', (event) => {
            // Update duration when the slider moves, only if not running
            if (!isRunning) {
                updateDuration(event.target.value);
            }
        });

        // Add a listener for window resize to recalculate the movement dimensions
        window.addEventListener('resize', calculateMovementDimensions);

        // --- Initialization ---
        function generateTrackSegments() {
            // Note: The visual segments are only for decoration. The train position is based on time percentage.
            const NUM_SEGMENTS = 60; 
            const segmentContainer = document.getElementById('track-segments');
            segmentContainer.innerHTML = ''; // Clear existing segments
            for (let i = 0; i < NUM_SEGMENTS; i++) {
                const segment = document.createElement('div');
                segment.className = 'track-segment bg-gray-300 rounded-sm';
                // Use flex spacing (justify-between) to handle spacing, but ensure the last element doesn't have a margin.
                segmentContainer.appendChild(segment);
            }
        }
        
        window.onload = function() {
            generateTrackSegments();
            calculateMovementDimensions(); // Initial calculation
            // Initial duration setup based on slider's default value
            updateDuration(durationSlider.value); 
        };
    </script>
</body>
</html>
