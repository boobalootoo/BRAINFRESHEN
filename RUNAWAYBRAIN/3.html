<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Station Train Timer</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom CSS variables for train positioning */
        :root {
            --train-translate-x: 0px; 
        }

        /* Define the position of the train using a CSS variable for smooth transitions */
        #train-container {
            position: absolute;
            top: 0; 
            left: 0%; 
            transform: translateX(var(--train-translate-x));
            transition: transform 1s linear; 
            will-change: transform;
            z-index: 10; /* Train is in front of stations */
        }
        
        /* Flipped train emoji for correct movement direction and LARGER size */
        #train-emoji {
            font-size: 4rem; /* Significantly larger train */
            transform: scaleX(-1);
            display: inline-block;
        }

        /* Adjust the size of the track container - now full width */
        #track-container {
            position: relative;
            height: 10rem; /* Increased height for bigger elements */
            width: 100%; 
        }
        
        /* Single element track bed using an image for sleepers */
        #track-bed {
            position: absolute;
            width: 100%;
            height: 3rem; /* Taller track for visual impact */
            bottom: 3.5rem; /* Starting position */
            overflow: hidden; 
            
            /* Use the provided track image URL */
            background-image: url('https://raw.githubusercontent.com/boobalootoo/BRAINFRESHEN/main/RUNAWAYBRAIN/tracks.png');
            background-repeat: no-repeat;
            /* Ensure the image stretches vertically to fill the new height */
            background-size: 100% 100%; 
            
            border-radius: 2px;
            z-index: 1; /* Below the train and stations */
        }


        /* Station marker styles (Positioned relative to the track bed) */
        .station-marker {
            position: absolute;
            /* Adjusted position to account for the taller track and better alignment */
            bottom: 6.5rem; 
            transform: translateX(-50%); /* Center the marker on the position */
            /* Increased size of the station */
            width: 200px; 
            height: 150px;
            z-index: 5; 
            pointer-events: none; 
            object-fit: contain; 
        }
        
        /* Custom button styling (smaller) */
        .control-button {
            /* Reduced padding and text size for a smaller look */
            @apply px-3 py-1.5 text-xs rounded-lg font-bold transition-all duration-200 shadow-md;
            @apply focus:outline-none focus:ring-2 focus:ring-offset-2;
        }

        .start-button {
            @apply bg-green-500 hover:bg-green-600 text-white focus:ring-green-300;
        }

        .mute-button {
            @apply bg-gray-500 hover:bg-gray-600 text-white focus:ring-gray-300;
        }

        /* Modal backdrop and container */
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.6);
        }
        
        /* Style adjustments for the entire controls area to make it smaller */
        #controls-container {
             /* Reduced padding (p-2 instead of p-4) and smaller shadow/border */
            @apply w-full max-w-xl bg-white p-2 rounded-xl shadow-lg border-t-2 border-gray-200 flex flex-col items-center space-y-2;
        }

        /* Style for the new, smaller status display */
        #compact-status-display {
            @apply text-base font-mono font-bold text-gray-800 text-center w-full py-1;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4 font-sans">

    <!-- Track & Train Area - Central Focus, now using full width -->
    <div class="flex justify-center w-full mb-12">
        <div id="track-container" class="mx-auto px-4 md:px-8">
            <!-- The Train Engine -->
            <div id="train-container" class="cursor-pointer" title="I am the Minute Express!">
                <!-- Flipped train emoji -->
                <span id="train-emoji" role="img" aria-label="Train Emoji">ðŸš‚</span>
            </div>

            <!-- Rails and Track Bed (The single track element) -->
            <div id="track-bed"></div>
            
            <!-- Station Markers (generated by JavaScript) -->
            <div id="station-markers-container">
                <!-- Markers generated by JavaScript -->
            </div>
        </div>
    </div>
    <!-- End Track & Train Area -->

    <!-- Controls & Settings Area -->
    <div id="controls-container" class="w-full max-w-xl bg-white p-4 rounded-xl shadow-xl border-t-4 border-gray-200 flex flex-col items-center space-y-4">
        
        <!-- COMPACT STATUS DISPLAY (Countdown and Task Name) -->
        <div id="compact-status-display" class="w-full">
            Ready (00:00)
        </div>
        
        <!-- Main Controls (Start/Stop & Mute) -->
        <div class="flex space-x-3">
            <button id="start-reset-button" class="control-button start-button">
                Start Journey
            </button>
            <button id="mute-button" class="control-button mute-button">
                <span id="mute-icon">ðŸ”ˆ</span> Mute
            </button>
        </div>

        <!-- Utility Row (Station Management & Status Preview) -->
        <div class="w-full flex justify-between items-center px-2">
            
            <!-- Station Management -->
            <div class="flex flex-col items-start text-xs">
                <button id="add-station-button" class="control-button bg-indigo-500 hover:bg-indigo-600 text-white focus:ring-indigo-300">
                    <span class="mr-1">âž•</span> Add Stations
                </button>
                <!-- Reduced margin-top and made text smaller -->
                <div id="station-list-preview" class="mt-1 text-gray-600 text-xs">
                    Stations: 0 (Total Duration: 0 min)
                </div>
            </div>

            <!-- Announcement Settings (Dropdown) -->
            <div class="relative">
                <button id="announcement-settings-toggle" class="control-button bg-yellow-500 hover:bg-yellow-600 text-white focus:ring-yellow-300 flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 mr-1" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M18 5v8a2 2 0 01-2 2h-5l-5 4v-4H4a2 2 0 01-2-2V5a2 2 0 012-2h12a2 2 0 012 2zM7 8H5v2h2V8zm6 0h-2v2h2V8z" clip-rule="evenodd" />
                    </svg>
                    Announce
                </button>

                <!-- Reduced width and padding/margins inside dropdown -->
                <div id="announcement-settings-dropdown" class="hidden absolute right-0 bottom-full mb-2 w-64 p-3 bg-white rounded-xl shadow-2xl z-20 border border-gray-200 text-xs">
                    <h3 class="font-bold text-gray-800 mb-2 border-b pb-1">Announcement Settings</h3>
                    
                    <div class="mb-2">
                        <label class="inline-flex items-center">
                            <input type="checkbox" id="arrival-announcement-toggle" checked class="form-checkbox text-blue-600 h-4 w-4 rounded focus:ring-blue-500">
                            <span class="ml-1 text-gray-700 font-medium">Arrival Announcement</span>
                        </label>
                        <p class="text-xs text-gray-500 ml-5">Plays 3 seconds before next task.</p>
                    </div>

                    <div class="mb-1">
                        <label class="inline-flex items-center">
                            <input type="checkbox" id="progress-announcement-toggle" class="form-checkbox text-blue-600 h-4 w-4 rounded focus:ring-blue-500">
                            <span class="ml-1 text-gray-700 font-medium">Progress Announcement</span>
                        </label>
                        <p class="text-xs text-gray-500 ml-5 mb-1">Announces upcoming stops periodically.</p>
                        
                        <div class="ml-5 flex items-center">
                            <label for="progress-interval" class="text-xs text-gray-600 mr-1">Frequency (seconds):</label>
                            <input type="number" id="progress-interval" min="10" value="30" class="w-12 p-0.5 border rounded text-xs text-center" disabled>
                        </div>
                    </div>
                </div>
            </div>
            
        </div>
    </div>

    <!-- Station Input Modal -->
    <div id="station-modal" class="hidden fixed inset-0 flex items-center justify-center p-4 z-50">
        <div class="modal-backdrop absolute inset-0"></div>
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-lg z-10 border-t-4 border-indigo-500">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">Define Journey Stations</h2>
            <div id="stations-input-container" class="space-y-3 max-h-80 overflow-y-auto pr-2">
                <!-- Station inputs go here -->
            </div>
            <div class="mt-4 flex justify-between items-center border-t pt-4">
                <button id="add-station-field" class="text-sm text-indigo-600 hover:text-indigo-800 font-semibold flex items-center">
                    <span class="text-xl mr-1">+</span> Add Task/Station
                </button>
                <button id="save-stations-button" class="control-button bg-indigo-500 hover:bg-indigo-600 text-white px-5 py-2">
                    Save Journey
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        // --- Configuration & State ---
        let isAudioInitialized = false;
        let isMuted = false;
        
        // Removed default stations. User must add them via the modal.
        let stations = []; 

        let totalDurationSeconds = 0; 
        let startTime = 0;
        let elapsedTimeOnPause = 0; 
        let animationFrameId = null;
        let isRunning = false;
        let nextStationIndex = 0;
        
        // Announcement State
        let arrivalAnnounceEnabled = true;
        let progressAnnounceEnabled = false;
        let progressIntervalSeconds = 30;
        let lastProgressAnnounceTime = 0; 
        let speechSynth = window.speechSynthesis;
        let arrivalAnnounced = false;

        // --- DOM Elements ---
        const trackContainer = document.getElementById('track-container');
        const trainContainer = document.getElementById('train-container');
        const trainEmoji = document.getElementById('train-emoji'); // Reference to the emoji element
        const stationMarkersContainer = document.getElementById('station-markers-container'); // NEW container for markers
        const startResetButton = document.getElementById('start-reset-button');
        const muteButton = document.getElementById('mute-button');
        const compactStatusDisplay = document.getElementById('compact-status-display');
        const muteIcon = document.getElementById('mute-icon');
        const addStationButton = document.getElementById('add-station-button');
        const stationModal = document.getElementById('station-modal');
        const stationsInputContainer = document.getElementById('stations-input-container');
        const addStationFieldButton = document.getElementById('add-station-field');
        const saveStationsButton = document.getElementById('save-stations-button');
        const stationListPreview = document.getElementById('station-list-preview');
        const settingsToggle = document.getElementById('announcement-settings-toggle');
        const settingsDropdown = document.getElementById('announcement-settings-dropdown');
        const arrivalToggle = document.getElementById('arrival-announcement-toggle');
        const progressToggle = document.getElementById('progress-announcement-toggle');
        const progressIntervalInput = document.getElementById('progress-interval');
        
        // --- Core Movement Variables ---
        let maxTravelDistancePx = 0; 
        let trainWidthPx = 0; 

        // --- Constants for Positioning ---
        // Estimated height of the train emoji (4rem in CSS) to align its base with the track
        const TRAIN_HEIGHT_ESTIMATE_PX = 64; 
        
        // ADJUSTED OFFSET: Decreased from 30px to 15px to lower the train and center it on the 3rem tall track.
        const TRAIN_VERTICAL_ALIGNMENT_OFFSET_PX = 15; 

        // --- Native Audio Setup ---
        let chugAudio = null;
        let chooAudio = null;
        
        // Raw GitHub URLs for audio files and the station image
        const CHUG_URL = 'https://raw.githubusercontent.com/boobalootoo/BRAINFRESHEN/main/RUNAWAYBRAIN/chug.wav';
        const CHOO_URL = 'https://raw.githubusercontent.com/boobalootoo/BRAINFRESHEN/main/RUNAWAYBRAIN/choo.mp3';
        const STATION_IMAGE_URL = 'https://raw.githubusercontent.com/boobalootoo/BRAINFRESHEN/main/RUNAWAYBRAIN/station.png'; 

        function initializeAudio() {
            if (isAudioInitialized) return;
            
            chugAudio = new Audio(CHUG_URL);
            chugAudio.loop = true;
            chugAudio.volume = 0.5;
            
            chooAudio = new Audio(CHOO_URL);
            chooAudio.volume = 1.0;
            
            chugAudio.load();
            chooAudio.load();

            isAudioInitialized = true;
            // Set initial mute state
            setMute(isMuted);
        }

        function speak(text) {
            if (isMuted || !speechSynth) return;
            speechSynth.cancel(); 
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.volume = 1.0; 
            speechSynth.speak(utterance);
        }

        function setMute(muteState) {
            isMuted = muteState;
            muteIcon.textContent = isMuted ? 'ðŸ”‡' : 'ðŸ”ˆ';
            muteButton.classList.toggle('bg-red-500', isMuted);
            muteButton.classList.toggle('bg-gray-500', !isMuted);

            if (chugAudio) chugAudio.volume = isMuted ? 0 : 0.5;
            if (chooAudio) chooAudio.volume = isMuted ? 0 : 1.0;

            if (isMuted && speechSynth) speechSynth.cancel();
        }
        
        // --- Station & Duration Logic ---

        function calculateTotalDuration() {
            totalDurationSeconds = stations.reduce((sum, station) => sum + (station.durationMinutes * 60), 0);
            updateStationListPreview();
        }

        function updateStationListPreview() {
            const totalMinutes = stations.reduce((sum, s) => sum + s.durationMinutes, 0);
            stationListPreview.innerHTML = `
                Stations: ${stations.length} 
                (Total Duration: ${totalMinutes} min)
                ${stations.length > 0 && nextStationIndex < stations.length ? `<br><span class="font-bold text-gray-900">Current Task: ${stations[nextStationIndex].name}</span>` : ''}
            `;
            generateStationMarkers(); // Only markers remain
        }
        
        function updateStatusDisplay(elapsedSeconds) {
            const remainingSeconds = Math.max(0, totalDurationSeconds - elapsedSeconds);
            const minutes = Math.floor(remainingSeconds / 60).toString().padStart(2, '0');
            const seconds = Math.floor(remainingSeconds % 60).toString().padStart(2, '0');
            
            let statusText = 'Ready (00:00)';

            if (totalDurationSeconds > 0) {
                const currentTaskName = stations[nextStationIndex]?.name || 'Final Stop';
                
                if (isRunning) {
                    statusText = `${currentTaskName}: ${minutes}:${seconds}`;
                } else if (elapsedSeconds < totalDurationSeconds) {
                    // Paused
                    statusText = `Paused (${currentTaskName}: ${minutes}:${seconds})`;
                } else {
                    // Finished
                    statusText = `Finished! (00:00)`;
                }
            }
            
            compactStatusDisplay.textContent = statusText;

            const isFinished = elapsedSeconds >= totalDurationSeconds && totalDurationSeconds > 0;
            
            startResetButton.textContent = isRunning ? 'Stop/Pause' : (isFinished ? 'Reset' : 'Start Journey');
            
            startResetButton.classList.toggle('start-button', !isRunning && !isFinished);
            startResetButton.classList.toggle('bg-red-500', isRunning);
            startResetButton.classList.toggle('bg-blue-500', !isRunning && isFinished);
            
            startResetButton.disabled = totalDurationSeconds === 0 && !isFinished;
        }

        // --- Core Movement and Announcement Logic ---

        function calculateMovementDimensions() {
            const trackWidth = trackContainer.getBoundingClientRect().width;
            
            // Re-query the elements to get the latest dimensions 
            const trackBed = document.getElementById('track-bed');
            const trainRect = trainEmoji.getBoundingClientRect();

            if (trackBed) {
                const trackContainerRect = trackContainer.getBoundingClientRect();
                const trackBedRect = trackBed.getBoundingClientRect();
                
                // Calculate the Y position of the TOP of the track bed relative to the track container
                const trackBedTopY = trackBedRect.top - trackContainerRect.top;

                // Adjust the train container's top position. 
                // We use the offset to visually center the train on the track.
                const trainTopPosition = trackBedTopY - TRAIN_HEIGHT_ESTIMATE_PX + TRAIN_VERTICAL_ALIGNMENT_OFFSET_PX;
                trainContainer.style.top = `${trainTopPosition}px`;
            }

            // Train width calculation (still uses the emoji's rendered size)
            trainWidthPx = trainRect.width * 0.8; 
            
            // Max travel distance is the full track width minus the train's visual width.
            // We subtract a small padding amount to prevent the train from going outside the track's visible area
            maxTravelDistancePx = trackWidth - trainWidthPx - 10; 
        }

        function announceUpcomingArrival() {
            if (!arrivalAnnounceEnabled || nextStationIndex >= stations.length) return;
            if (arrivalAnnounced) return;

            // The 'next station' in terms of the list is index+1, but we are announcing the arrival 
            // at the end of the *current* task's time (nextStationIndex).
            const nextStation = stations[nextStationIndex + 1];

            const arrivalName = nextStation ? nextStation.name : "the final destination";
            
            const arrivalText = `Attention: Approaching next stop, ${arrivalName}. Please prepare for arrival.`;
            speak(arrivalText);
            arrivalAnnounced = true;
        }

        function announceProgress(elapsedSeconds) {
            if (!progressAnnounceEnabled || totalDurationSeconds === 0) return;
            
            if (elapsedSeconds - lastProgressAnnounceTime < progressIntervalSeconds) return;

            const upcomingStations = stations.slice(nextStationIndex + 1);

            if (upcomingStations.length > 0) {
                const upcomingNames = upcomingStations.map(s => s.name).join(', then ');
                const progressText = `Current journey update. Next stops are: ${upcomingNames}.`;
                speak(progressText);
                lastProgressAnnounceTime = elapsedSeconds;
            } else if (nextStationIndex < stations.length) {
                // If we are on the last task and progress is enabled
                const currentTask = stations[nextStationIndex].name;
                const progressText = `Current task is ${currentTask}. Approaching final destination.`;
                speak(progressText);
                lastProgressAnnounceTime = elapsedSeconds;
            }
        }


        function updateTrainPosition(timestamp) {
            if (!isRunning) return;

            const timeElapsedSinceStart = (Date.now() - startTime) / 1000;
            const elapsedSeconds = timeElapsedSinceStart + elapsedTimeOnPause; 
            
            let percentage = (elapsedSeconds / totalDurationSeconds) * 100;
            
            if (percentage >= 100) {
                percentage = 100;
                stopTimer(true); 
            }

            const currentTravelPx = (percentage / 100) * maxTravelDistancePx;
            trainContainer.style.setProperty('--train-translate-x', `${Math.min(currentTravelPx, maxTravelDistancePx)}px`);

            updateStatusDisplay(elapsedSeconds);
            
            let cumulativeTime = 0;
            let currentStationReached = false;
            
            for (let i = 0; i < stations.length; i++) {
                const stationDuration = stations[i].durationMinutes * 60;
                
                if (elapsedSeconds < cumulativeTime + stationDuration) {
                    
                    if (nextStationIndex !== i) {
                         nextStationIndex = i;
                         arrivalAnnounced = false; 
                         updateStationListPreview(); 
                    }

                    currentStationReached = true;

                    // Check for arrival announcement (3 seconds before segment end)
                    if (arrivalAnnounceEnabled && elapsedSeconds > (cumulativeTime + stationDuration) - 3) {
                        announceUpcomingArrival();
                    }
                    break;
                }
                cumulativeTime += stationDuration;
            }

            if (!currentStationReached && nextStationIndex < stations.length) {
                nextStationIndex = stations.length; // Final state if all tasks are complete
            }
            
            announceProgress(elapsedSeconds);

            if (isRunning) {
                animationFrameId = requestAnimationFrame(updateTrainPosition);
            }
        }

        function startTimer() {
            if (isRunning || totalDurationSeconds === 0) return;
            
            initializeAudio(); 
            calculateMovementDimensions(); 
            
            lastProgressAnnounceTime = elapsedTimeOnPause; 

            startTime = Date.now();
            isRunning = true;
            
            const startPercentage = (elapsedTimeOnPause / totalDurationSeconds) * 100;
            const startTranslationPx = (startPercentage / 100) * maxTravelDistancePx;
            trainContainer.style.setProperty('--train-translate-x', `${Math.min(startTranslationPx, maxTravelDistancePx)}px`);
            
            if (chugAudio && !isMuted) {
                chugAudio.play().catch(e => console.error("Chugging sound playback failed:", e));
            }
            
            animationFrameId = requestAnimationFrame(updateTrainPosition);
        }

        function stopTimer(completed = false) {
            if (!isRunning && !completed) return; 
            
            isRunning = false;
            cancelAnimationFrame(animationFrameId);
            
            if (chugAudio) chugAudio.pause();
            if (speechSynth) speechSynth.cancel();

            const timeElapsedSinceStart = (Date.now() - startTime) / 1000;
            
            if (completed) {
                elapsedTimeOnPause = totalDurationSeconds; 
                trainContainer.style.setProperty('--train-translate-x', `${maxTravelDistancePx}px`); 
                nextStationIndex = stations.length;

                if (chooAudio && !isMuted) {
                    chooAudio.currentTime = 0;
                    chooAudio.play().catch(e => console.error("Choo sound playback failed:", e));
                }
                speak("Attention, we have arrived at the final destination. Journey completed.");
            } else {
                elapsedTimeOnPause += timeElapsedSinceStart;
            }
            
            updateStatusDisplay(elapsedTimeOnPause);
        }

        function resetTimer() {
            isRunning = false;
            cancelAnimationFrame(animationFrameId);
            if (chugAudio) {
                chugAudio.pause();
                chugAudio.currentTime = 0;
            }
            if (speechSynth) speechSynth.cancel();
            
            startTime = 0;
            elapsedTimeOnPause = 0; 
            nextStationIndex = 0;
            arrivalAnnounced = false;
            lastProgressAnnounceTime = 0;
            trainContainer.style.setProperty('--train-translate-x', `0px`);
            updateStatusDisplay(0);
            updateStationListPreview(); 
        }
        
        // --- Station Modal Management ---

        function renderStationInputs(currentStations) {
            stationsInputContainer.innerHTML = '';
            // If the array is empty, ensure one input field is available to start
            if (currentStations.length === 0) {
                 addStationField("Task 1", 5, false); // Add first blank field
                 currentStations = stations; 
            }
            
            currentStations.forEach((station, index) => {
                const div = document.createElement('div');
                div.className = 'flex items-center space-x-2 p-3 bg-gray-50 rounded-lg shadow-sm';
                div.setAttribute('data-id', station.id);
                
                div.innerHTML = `
                    <span class="text-gray-500 font-bold w-4">${index + 1}.</span>
                    <input type="text" value="${station.name}" placeholder="Station Name (e.g., Task 1)" data-field="name" class="flex-grow p-2 border rounded focus:ring-2 focus:ring-indigo-500 text-sm">
                    <input type="number" value="${station.durationMinutes}" min="1" max="60" data-field="duration" class="w-20 p-2 border rounded text-sm text-center focus:ring-2 focus:ring-indigo-500">
                    <span class="text-gray-600">min</span>
                    <button class="remove-station-btn text-red-500 hover:text-red-700 p-1 rounded-full hover:bg-red-100 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                        </svg>
                    </button>
                `;
                stationsInputContainer.appendChild(div);
            });
        }

        function addStationField(name = "New Task", duration = 5, shouldRender = true) {
            const newStation = { id: Date.now(), name: name, durationMinutes: duration };
            stations.push(newStation);
            if (shouldRender) {
                renderStationInputs(stations);
            }
        }

        function removeStation(id) {
            stations = stations.filter(s => s.id !== id);
            renderStationInputs(stations);
        }

        function saveStations() {
            const newStations = [];
            stationsInputContainer.querySelectorAll('[data-id]').forEach(div => {
                const nameInput = div.querySelector('input[data-field="name"]').value;
                const durationInput = parseInt(div.querySelector('input[data-field="duration"]').value);
                
                if (nameInput.trim() && durationInput > 0) {
                    newStations.push({
                        id: parseInt(div.getAttribute('data-id')),
                        name: nameInput,
                        durationMinutes: durationInput
                    });
                }
            });
            
            stations = newStations;
            calculateTotalDuration();
            stationModal.classList.add('hidden');
            resetTimer(); 
            updateStationListPreview();
            updateStatusDisplay(0);
        }

        // --- Station Marker Drawing ---

        function generateStationMarkers() {
            stationMarkersContainer.innerHTML = '';
            
            if (totalDurationSeconds === 0) {
                return;
            }
            
            // Draw Stations Markers
            let cumulativeTime = 0; 
            
            stations.forEach((station, index) => {
                cumulativeTime += station.durationMinutes * 60;
                
                const positionPercentage = (cumulativeTime / totalDurationSeconds) * 100;
                
                if (positionPercentage > 0 && positionPercentage <= 100) {
                    
                    const marker = document.createElement('img');
                    marker.src = STATION_IMAGE_URL;
                    marker.alt = `Station: ${station.name}`;
                    marker.title = `Station: ${station.name}`;
                    marker.className = 'station-marker';
                    
                    marker.style.left = `${positionPercentage}%`; 
                    
                    // Only add a marker for the end of a segment (start of the next)
                    if (positionPercentage < 100) { 
                        stationMarkersContainer.appendChild(marker);
                    }
                }
            });
        }
        
        // --- Initial Setup and Listeners ---
        
        window.onload = function() {
            // Initial setup and dimensions calculation
            calculateTotalDuration(); 
            calculateMovementDimensions(); 
            generateStationMarkers();
            
            // Initial status display
            updateStatusDisplay(0); 

            // Announcement Settings Listeners
            settingsToggle.addEventListener('click', () => {
                settingsDropdown.classList.toggle('hidden');
            });

            // Close dropdown if clicking outside
            document.addEventListener('click', (e) => {
                if (!settingsToggle.contains(e.target) && !settingsDropdown.contains(e.target)) {
                    settingsDropdown.classList.add('hidden');
                }
            });

            arrivalToggle.addEventListener('change', (e) => {
                arrivalAnnounceEnabled = e.target.checked;
            });
            
            progressToggle.addEventListener('change', (e) => {
                progressAnnounceEnabled = e.target.checked;
                progressIntervalInput.disabled = !e.target.checked;
                if (e.target.checked) lastProgressAnnounceTime = elapsedTimeOnPause - progressIntervalSeconds;
            });

            progressIntervalInput.addEventListener('change', (e) => {
                const val = parseInt(e.target.value, 10);
                if (val >= 10) {
                    progressIntervalSeconds = val;
                } else {
                    e.target.value = progressIntervalSeconds; 
                }
            });

            // Station Modal Listeners
            addStationButton.addEventListener('click', () => {
                stationModal.classList.remove('hidden');
                renderStationInputs(stations); 
            });

            // Close modal by clicking backdrop
            stationModal.querySelector('.modal-backdrop').addEventListener('click', () => {
                stationModal.classList.add('hidden');
            });
            
            addStationFieldButton.addEventListener('click', () => addStationField("New Task", 5));
            saveStationsButton.addEventListener('click', saveStations);

            stationsInputContainer.addEventListener('click', (e) => {
                if (e.target.closest('.remove-station-btn')) {
                    const id = parseInt(e.target.closest('[data-id]').getAttribute('data-id'));
                    removeStation(id);
                }
            });

            // Timer and Mute Listeners
            startResetButton.addEventListener('click', () => {
                const isFinished = elapsedTimeOnPause >= totalDurationSeconds && totalDurationSeconds > 0;
                
                if (isRunning) {
                    stopTimer(false); 
                } else if (isFinished) {
                    resetTimer();
                } else if (totalDurationSeconds > 0) {
                    startTimer(); 
                }
            });

            muteButton.addEventListener('click', () => {
                initializeAudio(); 
                setMute(!isMuted);
            });

            // Recalculate dimensions on resize
            window.addEventListener('resize', () => {
                calculateMovementDimensions();
                generateStationMarkers(); 
                
                // Keep train position correct after resize
                const startPercentage = (elapsedTimeOnPause / totalDurationSeconds) * 100;
                const startTranslationPx = (startPercentage / 100) * maxTravelDistancePx;
                trainContainer.style.setProperty('--train-translate-x', `${Math.min(startTranslationPx, maxTravelDistancePx)}px`);
            });
        };
    </script>
</body>
</html>
