<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV Thumbnail Viewer</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar styling for a cleaner look */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-thumb {
            background: #9ca3af;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-track {
            background: #f3f4f6;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
    </style>
</head>
<body>

    <div id="app" class="p-4 sm:p-8 max-w-7xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-extrabold text-gray-900 mb-2">Project Thumbnails Viewer</h1>
            <p class="text-gray-600">Visualizing data from the BRAINFRESHEN `info.csv`.</p>
            <!-- New: Project Count Display -->
            <p id="project-count" class="text-lg font-semibold text-blue-600 mt-4 leading-relaxed"></p>
        </header>

        <!-- Loading/Error Status -->
        <div id="status-message" class="text-center text-xl font-medium text-blue-600">
            <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-blue-600 inline-block" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            Loading CSV Data...
        </div>

        <!-- Data Grid Container -->
        <div id="data-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
            <!-- Content will be injected here -->
        </div>

    </div>

    <script>
        // --- Configuration ---
        const RAW_CSV_URL = 'https://raw.githubusercontent.com/boobalootoo/BRAINFRESHEN/main/instructables/info.csv';
        const FALLBACK_IMAGE = 'https://placehold.co/400x250/cbd5e1/4b5563?text=No+Image';
        const EXPECTED_ROW_COUNT = 140; 
        const EXPECTED_COLUMNS = 6; // url,title,description,thumbnail,tags,variants

        // --- DOM Elements ---
        const dataGrid = document.getElementById('data-grid');
        const statusMessage = document.getElementById('status-message');
        const projectCount = document.getElementById('project-count');
        
        /**
         * Extracts the YouTube video ID from a URL.
         * @param {string} url - The project URL.
         * @returns {string|null} The video ID or null.
         */
        function getYouTubeId(url) {
            const match = url.match(/[?&]v=([^&]+)/);
            return match ? match[1] : null;
        }

        /**
         * Determines the best image URL for the card, prioritizing:
         * 1. The provided thumbnail URL from the CSV.
         * 2. A generated YouTube thumbnail if the URL is a YouTube link.
         * 3. The generic fallback image.
         * @param {Object} rowData - The data object for the row.
         * @returns {string} The final image URL.
         */
        function getThumbnailUrl(rowData) {
            const rawThumbnail = rowData.thumbnail;
            const projectUrl = rowData.url;
            
            if (rawThumbnail) {
                return rawThumbnail;
            }
            
            // FIX: Ensure projectUrl is truthy (not null, undefined, or empty string) before calling includes()
            if (projectUrl && (projectUrl.includes('youtube.com') || projectUrl.includes('youtu.be'))) {
                const videoId = getYouTubeId(projectUrl);
                if (videoId) {
                    // Use YouTube's high-quality thumbnail format
                    return `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
                }
            }
            
            return FALLBACK_IMAGE;
        }

        /**
         * Reworked: Robust CSV to JSON parser that handles multi-line fields
         * by only considering a newline as a record break if it's NOT inside quotes.
         * This uses a character-by-character approach for maximum robustness.
         * @param {string} csv - The raw CSV string data.
         * @returns {Object} { records: Array<Object>, rawLinesRead: number }
         */
        function parseCSV(csv) {
            const dataString = csv.trim();
            const allRecords = [];
            let currentRecord = [];
            let currentField = "";
            let inQuotes = false;
            let rawLinesRead = 0;
            let isHeader = true;

            for (let i = 0; i < dataString.length; i++) {
                const char = dataString[i];
                const nextChar = dataString[i + 1];

                if (char === '"') {
                    // Handle escaped quotes (e.g., "" inside a quoted field)
                    if (nextChar === '"') {
                        currentField += char;
                        i++; // Skip the second quote
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    currentRecord.push(currentField);
                    currentField = "";
                } else if ((char === '\n' || char === '\r') && !inQuotes) {
                    // Newline found outside of quotes: End of record
                    if (char === '\r' && nextChar === '\n') {
                        // Skip \r if it's followed by \n (Windows CRLF)
                        continue;
                    }
                    
                    currentRecord.push(currentField);
                    currentField = "";
                    rawLinesRead++;

                    if (isHeader) {
                        isHeader = false;
                    } else if (currentRecord.length > 0) {
                        allRecords.push(currentRecord);
                    }
                    currentRecord = []; // Start new record
                } else if (char !== '\r') {
                    // Append character (including newlines if inside quotes)
                    currentField += char;
                }
            }

            // Handle the final field/record if any content remains
            if (currentField || currentRecord.length > 0) {
                currentRecord.push(currentField);
                if (!isHeader && currentRecord.some(f => f.trim() !== '')) {
                     allRecords.push(currentRecord);
                }
                rawLinesRead++;
            }
            
            // Extract headers from the first processed record (which is the header)
            const headers = (allRecords.shift() || []).map(h => h.trim());
            const numHeaders = headers.length;

            // Now, map the robustly parsed records to objects
            const correctlyParsedRows = allRecords.map((values, index) => {
                const rowObject = {};
                let isValid = values.length === numHeaders;

                // Salvaging logic (kept for safety, but should rarely be hit now)
                if (!isValid) {
                    console.warn(`Record ${index + 1} (Post-Parsing): Column mismatch. Expected ${numHeaders}, found ${values.length}. Attempting to salvage.`);
                    if (values.length > numHeaders) { values.length = numHeaders; }
                    while (values.length < numHeaders) { values.push(''); }
                }

                headers.forEach((header, i) => {
                    // Remove leading/trailing whitespace and outer quotes
                    rowObject[header] = (values[i] || '').trim().replace(/^"|"$/g, '');
                });

                rowObject.salvaged = !isValid;
                return rowObject;
            });
            
            return { records: correctlyParsedRows, rawLinesRead: rawLinesRead };
        }

        /**
         * Creates an HTML card element for a single data row.
         * @param {Object} rowData - The data object for the row (using header keys).
         * @returns {string} The HTML string for the card.
         */
        function createCard(rowData) {
            // Get data using header names
            const title = rowData.title || 'Untitled Project';
            const url = rowData.url || '#';
            const imageUrl = getThumbnailUrl(rowData); // <-- Use the new function
            const cardColor = rowData.salvaged ? 'bg-yellow-50 ring-2 ring-yellow-400' : 'bg-white';
            const warningText = rowData.salvaged ? 
                '<p class="text-sm font-medium text-yellow-700 p-2 bg-yellow-100 rounded-md mb-3">⚠️ Data warning: Column count was inconsistent on this row. Displayed data is an educated guess.</p>' 
                : '';

            // Start the card
            let cardHtml = `
                <a href="${url}" target="_blank" class="block">
                    <div class="${cardColor} rounded-xl shadow-lg hover:shadow-xl hover:ring-2 hover:ring-blue-500 transition-all duration-300 overflow-hidden h-full">
                        <!-- Data Warning Message (if applicable) -->
                        ${warningText}
                        <!-- Thumbnail Image -->
                        <img src="${imageUrl}" alt="${title} Thumbnail"
                            class="w-full h-48 object-cover object-center"
                            onerror="this.onerror=null; this.src='${FALLBACK_IMAGE}';"
                        >

                        <div class="p-4 sm:p-6">
                            <h2 class="text-xl font-bold text-gray-900 mb-3 line-clamp-2">${title}</h2>
                            <dl class="space-y-3">
                `;

            // Iterate over all data fields for details (excluding url, title, thumbnail)
            Object.keys(rowData).forEach(header => {
                const value = rowData[header];

                // Skip already displayed fields or internal flags
                if (header === 'url' || header === 'title' || header === 'thumbnail' || header === 'salvaged') {
                    return;
                }
                
                if (value) {
                    // Capitalize the first letter of the header for display
                    const displayHeader = header.charAt(0).toUpperCase() + header.slice(1);

                    // Display other data as definition list items
                    cardHtml += `
                        <div class="pt-2 border-t border-gray-100">
                            <dt class="text-sm font-semibold text-gray-500">${displayHeader}</dt>
                            <dd class="text-base text-gray-800 line-clamp-3">${value}</dd>
                        </div>
                    `;
                }
            });

            // Close the definition list and card
            cardHtml += `
                            </dl>
                        </div>
                    </div>
                </a>
            `;
            return cardHtml;
        }


        /**
         * Main function to fetch and render the data.
         */
        async function fetchAndRenderData() {
            // Implement exponential backoff for robust API calls
            const MAX_RETRIES = 5;
            let lastError = null;
            projectCount.textContent = ''; // Clear previous count while loading
            
            for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
                try {
                    const response = await fetch(RAW_CSV_URL);

                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }

                    const csvText = await response.text();
                    
                    const parseResult = parseCSV(csvText); 
                    const dataArray = parseResult.records;

                    const rawLinesRead = parseResult.rawLinesRead; 
                    const actualCount = dataArray.length; // The correct project count

                    if (actualCount === 0) {
                        statusMessage.className = 'text-center text-xl font-medium text-yellow-600 p-4';
                        statusMessage.textContent = 'CSV data is empty or could not be parsed.';
                        projectCount.textContent = 'No projects found.';
                        return; 
                    }

                    // Success: Update count and render data
                    
                    // --- Status Messaging ---
                    let isPerfectCount = actualCount === EXPECTED_ROW_COUNT;
                    let hasInconsistentRows = dataArray.some(row => row.salvaged);

                    // 1. Display the counts clearly
                    let countColor = 'text-blue-600';
                    if (isPerfectCount && !hasInconsistentRows) {
                         countColor = 'text-green-600';
                    } else if (actualCount < EXPECTED_ROW_COUNT || hasInconsistentRows) {
                        countColor = 'text-red-600';
                    } else if (actualCount > EXPECTED_ROW_COUNT) {
                        countColor = 'text-red-600';
                    }
                    
                    projectCount.className = `text-lg font-semibold ${countColor} mt-4 leading-relaxed`;
                    projectCount.innerHTML = `
                        <strong>Processed Projects: ${actualCount}</strong> (Expected: ${EXPECTED_ROW_COUNT})<br>
                        <span class="text-sm text-gray-500">Raw CSV Lines Read: ${rawLinesRead}</span>
                    `;

                    // 2. Add detailed warning if necessary
                    if (hasInconsistentRows) {
                        projectCount.innerHTML += '<br><span class="text-sm font-bold text-red-600">⚠️ Warning: Some project data had inconsistent column counts and was salvaged.</span>';
                    } else if (actualCount !== EXPECTED_ROW_COUNT) {
                         projectCount.innerHTML += `<br><span class="text-sm font-bold text-red-600">⚠️ Warning: The processed count (${actualCount}) does not match the expected count (${EXPECTED_ROW_COUNT}).</span>`;
                    }
                    
                    statusMessage.style.display = 'none';
                    dataGrid.innerHTML = dataArray.map(row => createCard(row)).join('');
                    return; // Success, exit function

                } catch (error) {
                    lastError = error;
                    // Log the specific error before retrying or failing
                    console.error('Attempt failed:', error); 
                    if (attempt < MAX_RETRIES - 1) {
                        const delay = Math.pow(2, attempt) * 1000; 
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
            }
            
            // If all retries fail
            console.error('Failed to fetch or render CSV data after multiple retries:', lastError);
            statusMessage.className = 'text-center text-xl font-medium text-red-600 p-4 bg-red-100 rounded-lg shadow';
            // Show a friendly error message
            statusMessage.innerHTML = `Error loading data: Something went wrong during processing. <br> The most likely cause is malformed data in your CSV. See console for details.`;
            projectCount.textContent = 'Failed to load project count.';
        }

        // Run the main function when the page loads
        document.addEventListener('DOMContentLoaded', fetchAndRenderData);
    </script>
</body>
</html>
